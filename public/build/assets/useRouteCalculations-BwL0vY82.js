import{r as x}from"./app-C7VlHLTB.js";const it=({mapboxKey:h,isOnline:S,activeSchedule:at,optimizedSiteOrder:M,completedSites:k,siteLocations:O,currentLocation:q,routeCoordinates:nt,routeInfo:rt,map:_,isMobile:J,addRouteLayer:w})=>{const I=x.useRef(new Map),[D,m]=x.useState([]),[R,p]=x.useState(null),[P,v]=x.useState(null),[W,Y]=x.useState([]),F=(t,e,o,a)=>{const n=(o-t)*Math.PI/180,i=(a-e)*Math.PI/180,u=Math.sin(n/2)*Math.sin(n/2)+Math.cos(t*Math.PI/180)*Math.cos(o*Math.PI/180)*Math.sin(i/2)*Math.sin(i/2);return 6371*(2*Math.atan2(Math.sqrt(u),Math.sqrt(1-u)))},g=t=>{if(t<60)return`${t} min`;{const e=Math.floor(t/60),o=t%60;return o===0?`${e}h`:`${e}h ${o}min`}},z=t=>{if(t<60)return`${t} minutes`;{const e=Math.floor(t/60),o=t%60;return o===0?`${e} hour${e>1?"s":""}`:`${e} hour${e>1?"s":""} ${o} minute${o>1?"s":""}`}},y=(t,e)=>{const o={data:e,timestamp:Date.now(),ttl:864e5};I.current.set(t,o);try{const a=JSON.parse(localStorage.getItem("routeCache")||"{}");a[t]=o,localStorage.setItem("routeCache",JSON.stringify(a))}catch(a){console.warn("Failed to cache route in localStorage:",a)}},$=t=>{const e=I.current.get(t);if(e&&Date.now()-e.timestamp<e.ttl)return e.data;try{const a=JSON.parse(localStorage.getItem("routeCache")||"{}")[t];if(a&&Date.now()-a.timestamp<a.ttl)return I.current.set(t,a),a.data}catch(o){console.warn("Failed to read route from cache:",o)}return null},E=()=>{for(let t=0;t<M.length;t++)if(!k.has(M[t].id))return t;return-1},G=()=>k.size===O.length,A=(t,e)=>{if(!t||!e)return;const o=[t,[parseFloat(e.longitude),parseFloat(e.latitude)]];m(o);const a=F(t[1],t[0],parseFloat(e.latitude),parseFloat(e.longitude)),r=Math.round(a*2);p({duration:r,formattedDuration:g(r),distance:a.toFixed(1),toSite:e.site_name,isFallback:!0,recalculated:!0}),setTimeout(()=>{_.current&&w()},300)},K=async t=>{if(!t||!M.length)return;const e=E();if(e===-1){console.log("All sites completed, no route to recalculate");return}const o=M[e];console.log(`Recalculating route from current position to: ${o.site_name}`);try{const a=`${t[0]},${t[1]};${parseFloat(o.longitude)},${parseFloat(o.latitude)}`,r=`current_to_site_${o.id}_${Date.now()}`,n=$(r);if(n&&!S){console.log("Using cached route (offline mode)"),m(n.route),p({duration:n.duration,formattedDuration:g(n.duration),distance:n.distance,toSite:o.site_name,recalculated:!0}),setTimeout(()=>{_.current&&w()},100);return}const i=await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${a}?access_token=${h}&geometries=geojson&overview=full&steps=true&alternatives=false`);if(!i.ok)throw new Error(`HTTP ${i.status}: ${i.statusText}`);const u=await i.json();if(u.routes&&u.routes.length>0){const c=u.routes[0],l=Math.round(c.duration/60),s={route:c.geometry.coordinates,duration:l,formattedDuration:g(l),distance:(c.distance/1e3).toFixed(1),toSite:o.site_name};m(c.geometry.coordinates),p({duration:l,formattedDuration:g(l),distance:(c.distance/1e3).toFixed(1),toSite:o.site_name,recalculated:!0}),y(r,s),console.log(`Route recalculated: Current position → ${o.site_name}`),setTimeout(()=>{_.current&&c.geometry.coordinates.length>0&&w()},300)}}catch(a){console.error("Error recalculating route from current position:",a),A(t,o)}},B=t=>{if(!q||!D.length||D.length<2)return!0;const e=F(t[1],t[0],D[0][1],D[0][0]),o=k.size>0,a=e>.2,r=!(R!=null&&R.recalculated),n=a||o&&r;return n&&console.log(`Recalculating route - Off route: ${a}, Completed sites: ${k.size}, Already recalculated: ${R==null?void 0:R.recalculated}`),n},T=t=>{const e=t.duration/60,a=t.distance/1e3/(e/60);let r="good",n="low";return a<20?(r="heavy",n="high"):a<40&&(r="moderate",n="medium"),{conditions:r,congestionLevel:n,averageSpeed:a.toFixed(1),estimatedDelay:a<40?"5-15 minutes":"0-5 minutes"}},j=(t,e,o,a)=>{const r=T(t),n=z(o);let i="",u="low";return o<10?(i=`Start from station. You'll reach ${e.site_name} in ${n}. Total ${a} stops.`,u="low"):o<60?(i=`Start from station. Head to ${e.site_name} - ${n} away. ${a} stops total. ${r.conditions==="heavy"?"Heavy traffic expected.":"Good road conditions."}`,u="medium"):(i=`Start from station. Long route to ${e.site_name} (${n}). ${a} stops. Consider taking breaks. ${r.conditions==="heavy"?"Significant delays expected.":""}`,u="high"),{text:i,urgency:u,suggestedAction:Q(o,r.conditions)}},Q=(t,e)=>t>120?"Consider alternative routes":e==="heavy"?"Leave early to avoid peak hours":t<15?"Proceed directly from station":"Normal driving conditions",b=(t,e)=>{if(!t||e.length===0)return e;const o=[...e],a=[],r=o.map(c=>{const l=F(parseFloat(t.latitude),parseFloat(t.longitude),parseFloat(c.latitude),parseFloat(c.longitude));return{...c,distance:l,coordinates:[parseFloat(c.longitude),parseFloat(c.latitude)]}});r.sort((c,l)=>c.distance-l.distance);const n=r[0];a.push(n);const i=r.slice(1);let u=n;for(;i.length>0;){let c=-1,l=1/0;for(let s=0;s<i.length;s++){const d=F(parseFloat(u.latitude),parseFloat(u.longitude),parseFloat(i[s].latitude),parseFloat(i[s].longitude));d<l&&(l=d,c=s)}c!==-1&&(u=i[c],a.push(u),i.splice(c,1))}return a},V=async(t,e)=>{if(!t||e.length===0)return null;try{console.log(`Calculating individual routes from driver to ${e.length} sites...`);const o=e.map(async(n,i)=>{const u=`${t[0]},${t[1]};${parseFloat(n.longitude)},${parseFloat(n.latitude)}`,c=`individual_route_${t[0]}_${t[1]}_to_site_${n.id}`,l=$(c);if(l&&!S)return{siteId:n.id,siteName:n.site_name,coordinates:l.route,duration:l.duration,distance:l.distance,sequence:i+1};try{const s=await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${u}?access_token=${h}&geometries=geojson&overview=full`);if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const d=await s.json();if(d.routes&&d.routes.length>0){const f=d.routes[0],C=Math.round(f.duration/60),H=(f.distance/1e3).toFixed(1),ot={siteId:n.id,siteName:n.site_name,coordinates:f.geometry.coordinates,duration:C,distance:H,sequence:i+1};return y(c,{route:f.geometry.coordinates,duration:C,distance:H}),ot}}catch(s){return console.error(`Error calculating route to ${n.site_name}:`,s),{siteId:n.id,siteName:n.site_name,coordinates:[t,[parseFloat(n.longitude),parseFloat(n.latitude)]],duration:Math.round(F(t[1],t[0],parseFloat(n.latitude),parseFloat(n.longitude))*2),distance:F(t[1],t[0],parseFloat(n.latitude),parseFloat(n.longitude)).toFixed(1),sequence:i+1,isFallback:!0}}return null}),r=(await Promise.all(o)).filter(n=>n!==null);return console.log(`Successfully calculated ${r.length} routes to all sites`),r}catch(o){return console.error("Error calculating routes to all sites:",o),null}},X=async(t,e)=>{if(!t||e.length===0)return null;try{console.log(`Calculating sequential route from current position through ${e.length} sites...`);const o=N(t,e),a=o[0],n=[t,...o.map(s=>[parseFloat(s.longitude),parseFloat(s.latitude)])].map(s=>`${s[0]},${s[1]}`).join(";"),i=`route_from_current_${n}`,u=$(i);if(u&&!S){console.log("Using cached route (offline mode)");const s={...u,isCached:!0};return v(s),s}const c=await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${n}?access_token=${h}&geometries=geojson&overview=full&steps=true`);if(!c.ok)throw new Error(`HTTP ${c.status}: ${c.statusText}`);const l=await c.json();if(l.routes&&l.routes.length>0){const s=l.routes[0],d=Math.round(s.duration/60),f={currentLocation:t,nearestSite:a,optimizedOrder:o,route:s.geometry.coordinates,duration:d,formattedDuration:g(d),distance:(s.distance/1e3).toFixed(1),trafficConditions:T(s),recommendation:j(s,a,d,o.length),isCached:!1};return v(f),y(i,f),console.log(`Sequential route calculated: Current position → ${o.map(C=>C.site_name).join(" → ")}`),f}}catch(o){console.error("Sequential route calculation from current location failed:",o);const a=`route_from_current_${t[0]}_${t[1]}`,r=$(a);if(r)return console.log("Using cached route as fallback"),v({...r,isCached:!0}),r}return null},N=(t,e)=>{if(!t||e.length===0)return e;const o=[...e],a=[],r=o.map(c=>{const l=F(t[1],t[0],parseFloat(c.latitude),parseFloat(c.longitude));return{...c,distance:l,coordinates:[parseFloat(c.longitude),parseFloat(c.latitude)]}});r.sort((c,l)=>c.distance-l.distance);const n=r[0];a.push(n);const i=r.slice(1);let u=n;for(;i.length>0;){let c=-1,l=1/0;for(let s=0;s<i.length;s++){const d=F(parseFloat(u.latitude),parseFloat(u.longitude),parseFloat(i[s].latitude),parseFloat(i[s].longitude));d<l&&(l=d,c=s)}c!==-1&&(u=i[c],a.push(u),i.splice(c,1))}return a},Z=async(t,e)=>{if(!t||e.length===0)return null;try{const o=b(t,e),a=o[0],n=[[parseFloat(t.longitude),parseFloat(t.latitude)],...o.map(s=>[parseFloat(s.longitude),parseFloat(s.latitude)])].map(s=>`${s[0]},${s[1]}`).join(";"),i=`route_${n}`,u=$(i);if(u&&!S){console.log("Using cached route (offline mode)");const s={...u,isCached:!0};return v(s),m(u.route),s}const c=await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${n}?access_token=${h}&geometries=geojson&overview=full&steps=true`);if(!c.ok)throw new Error(`HTTP ${c.status}: ${c.statusText}`);const l=await c.json();if(l.routes&&l.routes.length>0){const s=l.routes[0],d=Math.round(s.duration/60),f={station:t,nearestSite:a,optimizedOrder:o,route:s.geometry.coordinates,duration:d,formattedDuration:g(d),distance:(s.distance/1e3).toFixed(1),trafficConditions:T(s),recommendation:j(s,a,d,o.length),isCached:!1};return v(f),y(i,f),f}}catch(o){console.error("AI route analysis from station failed:",o);const a=$(`route_station_${t.id}`);if(a)return console.log("Using cached route as fallback"),v({...a,isCached:!0}),m(a.route),a}return null},L=async(t,e)=>{if(!(!t||!e||!h))try{const o=`${t[0]},${t[1]};${parseFloat(e.longitude)},${parseFloat(e.latitude)}`;console.log(`Calculating route to next site: ${e.site_name}`);const a=await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${o}?access_token=${h}&geometries=geojson&overview=full&steps=true&alternatives=false`);if(!a.ok)throw new Error(`HTTP ${a.status}: ${a.statusText}`);const r=await a.json();if(r.routes&&r.routes.length>0){const n=r.routes[0],i=Math.round(n.duration/60);m(n.geometry.coordinates),p({duration:i,formattedDuration:g(i),distance:(n.distance/1e3).toFixed(1),toSite:e.site_name}),setTimeout(()=>{_.current&&n.geometry.coordinates.length>0&&w()},500)}}catch(o){console.error("Error calculating route to next site:",o)}},tt=async(t,e)=>{if(!t||!e||!h){console.log("Missing data for route calculation:",{currentPos:t,nearestSiteToStation:e,mapboxKey:!!h});return}try{const o=`${t[0]},${t[1]};${parseFloat(e.longitude)},${parseFloat(e.latitude)}`;console.log("Calculating route from current location to nearest site from station:",o);const a=`current_to_nearest_from_station_${o}`,r=$(a);if(r&&!S)return console.log("Using cached route to nearest site from station (offline mode)"),m(r.route),p({duration:r.duration,formattedDuration:g(r.duration),distance:r.distance,toSite:e.site_name}),setTimeout(()=>{_.current&&w()},100),r;const n=await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${o}?access_token=${h}&geometries=geojson&overview=full&steps=true&alternatives=false`);if(!n.ok)throw new Error(`HTTP ${n.status}: ${n.statusText}`);const i=await n.json();if(i.routes&&i.routes.length>0){const u=i.routes[0],c=Math.round(u.duration/60),l={route:u.geometry.coordinates,duration:c,formattedDuration:g(c),distance:(u.distance/1e3).toFixed(1),toSite:e.site_name};return m(u.geometry.coordinates),p({duration:c,formattedDuration:g(c),distance:(u.distance/1e3).toFixed(1),toSite:e.site_name}),y(a,l),console.log(`Route calculated: Your location → ${e.site_name} (nearest to station)`),setTimeout(()=>{_.current&&u.geometry.coordinates.length>0&&w()},500),l}}catch(o){console.error("Error calculating route to nearest site from station:",o);const a=`current_to_nearest_from_station_${e.id}`,r=$(a);r&&(console.log("Using cached route as fallback"),m(r.route),p({duration:r.duration,formattedDuration:g(r.duration),distance:r.distance,toSite:e.site_name}),setTimeout(()=>{_.current&&w()},100))}return null},et=async(t,e)=>{var o,a;if(!(!h||t.length<1))try{const r=e?b(e,t):U(t),n=e?[`${e.longitude},${e.latitude}`,...r.map(s=>`${parseFloat(s.longitude)},${parseFloat(s.latitude)}`)].join(";"):r.map(s=>`${parseFloat(s.longitude)},${parseFloat(s.latitude)}`).join(";"),i=`route_${n}`,u=$(i);if(u&&!S){console.log("Using cached route data (offline mode)"),m(u.route),p({duration:u.duration,formattedDuration:g(u.duration),distance:u.distance,toSite:u.toSite});return}const c=await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${n}?access_token=${h}&geometries=geojson&overview=full&steps=true&alternatives=false&continue_straight=false`);if(!c.ok)throw new Error(`HTTP ${c.status}: ${c.statusText}`);const l=await c.json();if(l.routes&&l.routes.length>0){const s=l.routes.reduce((f,C)=>C.duration<f.duration?C:f),d=Math.round(s.duration/60);m(s.geometry.coordinates),p({duration:d,formattedDuration:g(d),distance:(s.distance/1e3).toFixed(1),toSite:(o=r[0])==null?void 0:o.site_name}),y(i,{route:s.geometry.coordinates,duration:d,distance:(s.distance/1e3).toFixed(1),toSite:(a=r[0])==null?void 0:a.site_name})}}catch(r){console.error("Error calculating route:",r);const n=`route_${t.map(u=>`${u.longitude},${u.latitude}`).join(";")}`,i=$(n);if(i)console.log("Using cached route as fallback"),m(i.route),p({duration:i.duration,formattedDuration:g(i.duration),distance:i.distance,toSite:i.toSite});else{const u=t.map(c=>[parseFloat(c.longitude),parseFloat(c.latitude)]);m(u)}}},U=t=>{if(t.length<=2)return t;const e=new Set,o=[];let a=t[0];for(o.push(a),e.add(0);o.length<t.length;){let r=-1,n=1/0;for(let i=0;i<t.length;i++)if(!e.has(i)){const u=F(parseFloat(a.latitude),parseFloat(a.longitude),parseFloat(t[i].latitude),parseFloat(t[i].longitude));u<n&&(n=u,r=i)}r!==-1&&(a=t[r],o.push(a),e.add(r))}return o};return{routeCoordinates:D,routeInfo:R,aiOptimizedRoute:P,allSiteRoutes:W,setRouteCoordinates:m,setRouteInfo:p,setAiOptimizedRoute:v,setAllSiteRoutes:Y,calculateDistance:F,formatDuration:g,formatDurationForAI:z,cacheRoute:y,getCachedRoute:$,getNextUncompletedSiteIndex:E,areAllSitesCompleted:G,createStraightLineRoute:A,recalculateRouteFromCurrentPosition:K,shouldRecalculateRoute:B,analyzeTrafficConditions:T,generateRecommendation:j,optimizeSiteOrderFromStation:b,optimizeSiteOrder:U,optimizeSiteOrderFromLocation:N,analyzeAndOptimizeRouteFromStation:Z,analyzeAndOptimizeRouteFromCurrentLocation:X,calculateRouteToNextSite:L,calculateRouteToNearestSiteFromStation:tt,calculateOptimalRoute:et,calculateRoutesToAllSites:V}};export{it as useRouteCalculations};
