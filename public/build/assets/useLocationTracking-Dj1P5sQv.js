import{r,a as j}from"./app-wN3IebrI.js";const ot=({scheduleId:q,activeSchedule:J,siteLocations:c,completedSites:K,optimizedSiteOrder:Q,currentSiteIndex:X,isTaskActive:Y,onTaskComplete:Z,map:h,isMobile:C,currentLocation:U,routeCoordinates:u,routeInfo:tt,smoothUpdateUserLocation:g,checkSiteProximity:d,recalculateRouteFromCurrentPosition:k,shouldRecalculateRoute:$,updateUserLocationSource:b,animatePulse:x,clearUserLocationLayers:w,updateCurrentLocationMarker:D,handleLocationError:y,sendLocationToReverb:f})=>{const m=r.useRef(null),i=r.useRef(null),E=r.useRef(null),M=r.useRef(null),N=r.useRef(null),P=r.useRef(null),[S,p]=r.useState(!1),[_,s]=r.useState(null),[G,I]=r.useState(null),[H,F]=r.useState(null),W=(a=5e3)=>{if(S){console.log("Fake location test already running");return}console.log("ðŸš€ Starting fake location test"),p(!0);const o=[{lat:8.483,lng:125.9485,name:"Start Point"},{lat:8.49,lng:125.955,name:"Point A"},{lat:8.495,lng:125.96,name:"Point B"},{lat:8.5,lng:125.965,name:"Point C"},{lat:8.505,lng:125.97,name:"Point D"}];let n=0;i.current=setInterval(async()=>{const t=o[n];try{console.log(`ðŸ“ Sending fake location: ${t.lat}, ${t.lng} (${t.name})`);const e=[t.lng,t.lat];s(e),await f(t.lat,t.lng,10),g(t.lat,t.lng),c.length>0&&(d(e,c)?(console.log("Site completed in fake location test, recalculating route"),k(e)):$(e)&&k(e)),console.log(`âœ… Fake location sent: ${t.name}`),n=(n+1)%o.length}catch(e){console.error("âŒ Failed to send fake location:",e)}},a)},v=()=>{i.current&&(clearInterval(i.current),i.current=null,p(!1),console.log("ðŸ›‘ Fake location test stopped"))},z=async(a,o)=>{try{console.log(`ðŸ“ Sending test location: ${a}, ${o}`);const n=[o,a];return s(n),await f(a,o,10),g(a,o),c.length>0&&d(n,c),console.log("âœ… Test location sent successfully"),!0}catch(n){return console.error("âŒ Failed to send test location:",n),!1}},B=async(a=3e3)=>{if(!u||u.length===0){console.error("No route coordinates available for simulation");return}if(S){console.log("Fake location simulation already running");return}console.log("ðŸ›£ï¸ Starting route following simulation"),p(!0);let o=0;return i.current=setInterval(async()=>{if(o>=u.length){console.log("ðŸ Route simulation completed"),v();return}const[n,t]=u[o];try{console.log(`ðŸ“ Route point ${o+1}/${u.length}: ${t}, ${n}`);const e=[n,t];s(e),await f(t,n,5),g(t,n),c.length>0&&d(e,c)&&(console.log("Site completed during simulation, forcing immediate route recalculation"),setTimeout(()=>{k(e)},100)),o++}catch(e){console.error("âŒ Failed to send route location:",e)}},a),i.current},O=()=>{if(!navigator.geolocation){console.error("Geolocation is not supported by this browser");return}A();const a={enableHighAccuracy:!0,timeout:1e4,maximumAge:0};console.log("Starting continuous real-time location tracking...");let o=0;const n=5e3;m.current=navigator.geolocation.watchPosition(async t=>{const{latitude:e,longitude:l,accuracy:R}=t.coords,L=[l,e],T=Date.now();if(!(T-o<n)){console.log("Sending location update to backend:",{lat:e,lng:l,accuracy:R});try{await f(e,l,R),o=T}catch(V){console.error("Failed to send location to backend:",V)}s(L),I(R),F(new Date),g(e,l),c.length>0&&d(L,c)}},t=>{console.error("Error in real-time location tracking:",t),y(t)},a),h.current&&(h.current.hasUserInteracted=()=>!1,h.current.on("movestart",()=>{h.current.hasUserInteracted=()=>!0}))},A=()=>{m.current!==null&&(navigator.geolocation.clearWatch(m.current),m.current=null),w()};return{locationWatcherRef:m,fakeLocationIntervalRef:i,animationFrameRef:E,currentLocationMarkerRef:M,userLocationSourceRef:N,userLocationLayerRef:P,isFakeLocationActive:S,currentLocation:_,locationAccuracy:G,lastLocationUpdate:H,setCurrentLocation:s,setLocationAccuracy:I,setLastLocationUpdate:F,setIsFakeLocationActive:p,startFakeLocationTest:W,stopFakeLocationTest:v,sendTestLocation:z,simulateRouteFollowing:B,startRealtimeLocationTracking:O,stopRealtimeLocationTracking:A,startRealtimeLocationSharing:async a=>{if(!navigator.geolocation){console.error("Geolocation not supported");return}return navigator.geolocation.watchPosition(async n=>{const{latitude:t,longitude:e}=n.coords;try{(await j.post("/driver/location/update",{latitude:t,longitude:e,schedule_id:a})).data.success&&(console.log("Location updated and broadcasted"),s([e,t]),g(t,e),c.length>0&&d([e,t],c))}catch(l){console.error("Failed to update location:",l)}},n=>{console.error("Location tracking error:",n)},{enableHighAccuracy:!0,timeout:1e4,maximumAge:0})},sendLocationToReverb:f,handleLocationError:y,updateCurrentLocationMarker:D,updateUserLocationSource:b,animatePulse:x,clearUserLocationLayers:w}};export{ot as useLocationTracking};
